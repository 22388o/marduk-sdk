export interface GetPairsResponse {
  info: string[],
  warnings: string[],
  pairs: {
    [key: string]: {
      rate: number,
      limits: {
        maximal: number,
        minimal: number,
        maximalZeroConf: {
          baseAsset: number,
          quoteAsset: number
        }
      },
      fees: {
        percentage: number,
        minerFees: {
          baseAsset: {
            normal: number,
            reverse: {
              claim: number,
              lockup: number
            }
          },
          quoteAsset: {
            normal: number,
            reverse: {
              claim: number,
              lockup: number
            }
          }
        }
      },
      hash: number
    }
  }

}

export interface GetNodesResponse {
  nodes: {
    [key: string]: {
      nodeKey: string,
      uris: string[]
    }
  }
}

export interface GetTimeoutResponse {
  timeouts: {
    [key: string]: {
      base: number,
      quote: number
    }
  }
}

export interface GetContractsResponse {
  ethereum: {
    network: {
      chainId: number
    },
    swapContracts: {
      EtherSwap: string,
      ERC20Swap: string
    },
    tokens: {
      [key: string]: string
    }
  }
}

export interface GetFeeEstimationResponse {
    [key: string]: number
}

export interface GetContractsResponse {
  ethereum: {
    network: {
      chainId: number
    },
    swapContracts: {
      EtherSwap: string,
      ERC20Swap: string
    },
    tokens: {
      [key: string]: string
    }
  }
}

export interface GetTransactionResponse {
  transactionHex: string,
}

export interface BroadcastTransactionResponse {
  transactionId: string,
}


export interface GetSwapTransactionResponse {
  transactionHex: string,
  timeoutBlockHeight: number,
  timeoutEta: number // If the HTLC has not timed out yet, there will be an additional value in the response: UNIX timestamp at which the HTLC is expected to time out
}

export interface GetSwapStatusResponse {
  status: string, // status of the swap
  transaction: {
    id: string,
    hex: string,
    eta: number //  if the status is transaction.mempool, this value is the estimated time of arrival (ETA) in blocks of when the transaction will be confirmed (only set for transactions on UTXO based chains)
  }
  zeroConfRejected: boolean // set to true for Swaps with the status transaction.mempool and a lockup transaction that is not eligible for 0-conf
  failureReason: string // set if the status indicates that the Swap failed and the status itself would be ambiguous
}

export interface GetSwapRatesResponse {
  invoiceAmount: string
}

export interface SetInvoiceSwap {
  acceptZeroConf: boolean,
  expectedAmount: number,
  bip21: string
}

export interface CreateSwapRequest {
  type: 'reversesubmarine' | 'submarine' , // type of the swap to create; always submarine for normal swaps
  pairId: string // the pair on which the swap should be created
  orderSide: string // either buy or sell depending on what the user wants

  // If you already know the amount you want to swap you should also set invoice.
  invoice: string // the invoice of the user that should be paid
  // If the amount is not known, a preimage hash should be specified. The invoice that is set during the lifecycle of the Submarine Swap has to have the same preimage hash as the one specified when creating the swap.
  // amount of the invoice that will be generated by Boltz

  preimageHash: string // hash of a preimage that will be used for the invoice that is set later on
  onchainAmount: number // amount Boltz will lock in the onchain HTLC
  // In case the client wants to verify the pair data fetched by it is still accurate, the pairHash argument can be passed.

  pairHash: string // hash string in the pair object of /getpairs

  // Boltz also supports opening a channel to your node before paying your invoice. To ensure that this service works as advertised make sure to connect your Lightning node to ours before creating the swap. You can either query the URIs of our Lightning nodes with /getnodes, find them in the FAQ section of our website or on Lightning explorers like 1ML under the query "Boltz". To let Boltz open a channel to you have to set a couple more values in the request when creating a swap:

  // a JSON object that contains all the information relevant to the creation of the channel
  channel: {
    auto:  string //whether Boltz should dynamically decide if a channel should be created based on whether the invoice you provided can be paid without opening a channel. More modes will be added in the future
    private: string //  whether the channel to your node should be private
    inboundLiquidity: string // percentage of the channel balance that Boltz should provide as inbound liquidity for your node. The maximal value here is 50, which means that the channel will be perfectly balanced 50/50
  }

  // Swaps from UTXO based chains like Bitcoin work by deriving an address based on the preimage hash of the invoice and the refund publick key of the user and waiting until the user sends coins to that generated address.

  // Requests have to contain one additional parameter:
  refundPublicKey: string // public key of a keypair that will allow the user to refund the locked up coins once the time lock is expired

}

export interface CreateSwapResponse {
  id: string // id of the freshly created swap
  timeoutBlockHeight: string // block height at which the swap will be cancelled
  address: string // address in which the coins will be locked up. For UTXO based chains this is a SegWit P2SHP2WSH (P2WSH nested in a P2SH) for the sake of compatibility and for Ethereum it is the address of the contract that needs to be used

  //If you set the invoice you will also have these values in the response:
  acceptZeroConf: string// whether Boltz will accept 0-conf for this swap
  expectedAmount: string // the amount that Boltz expects you to lock in the onchain HTLC

  // UTXO based chains will have the following additional values in the response:
  redeemScript: string // redeem script from which the address is derived. The redeem script can and should be used to verify that the Boltz instance didn't try to cheat by providing an address without a HTLC

  // If the invoice has been set in the request, you will also get this value:
  bip21: string // a BIP21 payment request for the expectedAmount of coins and the address

  // ethereum
  claimAddress: string // which is the Ethereum address of Boltz. It has to be specified in the lock function of the swap contract
}

export interface SetInvoiceResponse {
  // What is returned when the invoice is set depends on the status of the Submarine Swap. If no coins were sent already (status swap.created) the endpoint will return a JSON object with these values:

  acceptZeroConf: string // whether Boltz will accept 0-conf for this swap
  expectedAmount: string // the amount that Boltz expects you to lock in the onchain HTLC
  bip21: string // a BIP21 payment request for the expectedAmount of coins and the address (only set when swapping from UTXO based chains)
  // If onchain coins were sent already (status transaction.mempool or transaction.confirmed) the endpoint will return an empty JSON object.

  //In case this endpoint is called again after an invoice was set and Boltz tried to pay it already:

  error: string // error message explaining that Boltz tried to pay the invoice already and that it cannot be changed anymore
  invoice: string //the invoice that set by the client and will be used for the Submarine Swap
}